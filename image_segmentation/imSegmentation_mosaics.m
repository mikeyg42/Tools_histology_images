function imSegmentation_mosaics
% Syntax OPT 1: loopingSegmentation_mosaics (... no inut/output, instead modify the first few lines of this .m file)
% Syntax OPT 2: {mask1, mask2,..., maskn} = loopingSegmentation_mosaics {path1, path2,...pathn};
% This function is the parent function for all of the foreground/background
% image segmentation code I've written for whole-slide image (WSI) mosaics.

% WAIT! STOP! Before you proceed, open up the "setts_and_prefs.m and set all of your settings and preferences!!
% Every customizable feature of the code should be found there so there is unlikely any need to modify the code files

% This code makes two assumptions, for which there are potentially work arounds but they
% are not idea. First, it is assumed that the "whole" in whole slide imaging was observed...
% This means that the ENTIRE foreground is contained within the image - ie, there
% should be a large blob in the middle of a white background,and minimal/zero edge
% intersections of theforeground and the image outer extent boundaru. I've tried to keep flexibile
% so that a lot of the code will work with this assumption not met. But its far from ideal.
% Some aspects of the code will also assume each WSI has 1 blob... I continue to work on
% handling case of 2+ blobs.

% Second assumption is that this is brightfield, not fluorescent microscopy.Inverted
% images with high tissue autofluroescence might work in some instances, but I've had little
% success in my tests. A different set of tools is advisable for such images.

% Note: The script, as is, relies heavily upon the file naming convention.
%  Prepending my convention to your own is easy and will ensure you have no
%  issues. It requires three, underscore-seperated identifiers:

%               {1} _ {2} _ {3} _ {optional 4}.tiff
%        ie. "GROUPid_SAMPLEid_STAINid_ExtraInfo.tiff

% {1} - experimental group ID. I often use: "SICK" or "HEALTHY".
% {2} - SAMPLE id. I often use A, B, C, ...
% {3} - identification of the particular staining performed in that image
%       (H+E, ect.) For IHC usually the particular target antigen for
%       IHC-Dab (e.g. CD31, Sox17, ...)
% {4} - whatever other notes/identifiers you want, it should not mess up
%       anything (...except potentially you shouldn't include more underscores
%       or repeat one of the identifiers from {1}, {2}, or {3}?)

% After the input and settings are parsed, images are preprocessed. Raw image mosaics
% always exhibit a hallmark, frustrating grid-pattern (I'll refer to as
% the "picnic tablecloth effect"). The best way to prevent this is careful
% setting up of Kohler illumination and optimizing of image acquisition settings.
% But, after acquisition, your solution depends on how your downstream
% analyses's sensitivity. Here I've addressed the picnic table effect with a
% background correction algorithm (using the tophat filter). If this is
% insufficient, you can modify preprocessingRawRGBims.m and backgroundCorrectRGB.m
% And for more serious problems, check out the open source dockerized
% workflow called MCMICRO, which uses the program BaSiC, (also an ImageJ plugin).

% Michael Glendinning, 2023

close force all
%clear all

[mySettings] = setts_and_prefs;

data = parseDataset(mySettings, 'segmentation'); % inside data will be a image datastore from which you can read in images
%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%--%

counter = 7;
% each file in our image datastore gets a number. Set counter to be = to the
% # you want to start on. After a full loop, counter is reset to counter+1.
%   Images in the datastore are in the same order as they will be in
%   the field "filenames" of the structural array "mySettings"...

scaleFactor = mySettings.seg.seg_scaleFactor;
USETHIS_scaleFactor = 1/scaleFactor;

%%  3. load up 1st image and start processing

nImages = numel(data.imageNames);

while counter<=nImages % loop to go through your entire image datastore
    activeFilename = strip(data.imageNames{counter}, 'both', '/'); % the strip command will remove leading/trailing slashes
    
    % print the date and time into command window so you can track efficiency
    printStartTime_imProcessing(activeFilename);
    
    % retrieve from data structural array generated by the parsing function what needs doing
    tf_adjIm = data.segInfo(counter).needAdjRGB ;
    tf_mask = data.segInfo(counter).needMask ;
    
    %use imfinfo to determine the size of the raw and processed images
    info = imfinfo(data.imageDS.Files{counter});
    sz = [info.Height; info.Width].*USETHIS_scaleFactor;
    %-------------------------------------------------------------------------%
    if tf_adjIm && tf_mask
        % read in the raw image...
        [imgCurrentlyBig, ~] = readimage(data.imageDS, counter);
        
        % preprocess RGB image:
        %1. convert precision to float (double)
        %2. apply the downsampling scaleFactor,
        %3. background/flatfield correction w/tophat
        imAdjRGB = preprocessRawRGBims(imgCurrentlyBig, USETHIS_scaleFactor);
        
        % call the segmentation GUI function for foreground/background segmenting
        finalbinaryMask = segmentationWrapper(imAdjRGB);
    end
    %-------------------------------------------------------------------------%
    
    if ~tf_adjIm && tf_mask
        save_fileList_adjRGB = string({dir(fullfile(mySettings.directories.saveSegm_adjImages, '*')).name});
        fileComponents = split(activeFilename, {'/', '_', '.'});
        idx_rgb = contains(save_fileList_adjRGB, 'RGB') & contains(save_fileList_adjRGB, fileComponents{2}) & contains(save_fileList_adjRGB, fileComponents{3});
        % the above expression selects all files with RGB in the filename (which all will
        % have been saved with, as well as the 3rd and 2nd comoponents of the filename,
        % which cooresponds to their descriptions in the inital description of function.
        % {1} is group ID, {2} is sample ID, and {3} is stain ID
        
        my1savedfile = save_fileList_adjRGB(find(idx_rgb));
        assert(sum(idx_rgb)==1);
        
        % tiff files = RGB, so read in the RGB image match from saveDir
        imAdjRGB = imread(strcat(mySettings.directories.saveSegm_adjImages, my1savedfile));
        imAdjRGB = imresize(imAdjRGB, [sz(1), sz(2), 3], {@oscResampling, 4});
        
        % call the segmentation GUI function for foreground/background segmenting
        finalbinaryMask = segmentationWrapper(imAdjRGB);
    end
    %-------------------------------------------------------------------------%
    if tf_adjIm && ~tf_mask
        save_fileList_mask = string({dir(fullfile(mySettings.directories.saveSegm_foregroundMask, '*')).name});
        fileComponents = split(activeFilename, {'/', '_', '.'});
        idx_mask = contains(save_fileList_mask, 'mask') & contains(save_fileList_mask, fileComponents{3}) & contains(save_fileList_mask, fileComponents{4});
        my1savedfile = save_fileList_mask(find(idx_mask));
        
        assert(sum(idx_mask)==1);
        
        try binaryMask = imread(strcat(mySettings.directories.saveSegm_foregroundMask, my1savedfile), 'BackgroundColor', 0);
        catch
            binaryMask = imread(strcat(mySettings.directories.saveSegm_foregroundMask, my1savedfile));
        end
        binaryMask = imresize(binaryMask, [sz(1), sz(2)], {@oscResampling, 4});
        binaryMask = logical(binaryMask);
        
        % read into workspace the raw image file, then the preprocessing fcn to generate
        % the adjusted RGBim. then we can proceed to segmentation function
        [imgCurrentlyBig, ~] = readimage(data.imageDS, counter);
        imAdjRGB = preprocessRawRGBims(imgCurrentlyBig, USETHIS_scaleFactor);
        
        if mySettings.seg.seg_doubleCheckSavedMasks
            finalbinaryMask = segmentationWrapper(imAdjRGB, binaryMask);
        else
            finalbinaryMask = binaryMask;
        end
    end
    %-------------------------------------------------------------------------%
    if ~tf_adjIm && ~tf_mask
        if ~mySettings.seg.seg_doubleCheckSavedMasks
            counter = counter+1;
            continue
        else
            
            fileComponents = split(activeFilename, {'/', '_', '.'});
            
            save_fileList_mask = string({dir(fullfile(mySettings.directories.saveSegm_foregroundMask, '*')).name});
            
            % you'll need the binary mask image either way, so get it:
            idx_mask = contains(save_fileList_mask, 'mask') & contains(save_fileList_adjRGB, fileComponents{3}) & contains(save_fileList_adjRGB, fileComponents{4});
            mysavedMask = save_fileList_mask(find(idx_mask));
            
            try binaryMask = imread(strcat(mySettings.directories.saveSegm_foregroundMask, mysavedMask), 'BackgroundColor', 0);
            catch
                binaryMask = imread(strcat(mySettings.directories.saveSegm_foregroundMask, mysavedMask));
            end
            
            binaryMask = imresize(binaryMask, [sz(1), sz(2)], {@oscResampling, 4});
            binaryMask = logical(binaryMask);
            
            %get the RGB image as well
            save_fileList_adjRGB = string({dir(fullfile(mySettings.directories.saveSegm_adjImages, '*')).name});
            
            idx_rgb = contains(save_fileList_adjRGB, 'RGB') & contains(save_fileList_adjRGB, fileComponents{3}) & contains(save_fileList_adjRGB, fileComponents{4});
            mysavedImg = save_fileList_mask(find(idx_rgb));
            
            imAdjRGB = imread(strcat(mySettings.directories.saveSegm_adjImages, mysavedImg));
            
            finalbinaryMask = segmentationWrapper(imAdjRGB, binaryMask);
        end
    end
    
    %-|---%---|---%---|---%---|--%---|---%---|---%---|---%---|---%---|---%---|---%---|
    
    %% 4. Saving!!
    
    % CAUTION: this will overwrite whatever might have been there before!!
    % CAUTION: if you rescale back up, for particularly large images MATLAB may fail to save file and become overwhelmed!!!
    
    mask_FMT = mySettings.fileFormats.segm_saveFMT_adjImage;
    RGB_FMT = mySettings.fileFormats.segm_saveFMT_foregroundMask;
    
    if mySettings.seg.seg_resizeBig
        finalSize = [info.Height, info.Width];
        finalbinaryMask = imresize(finalbinaryMask, finalSize, {@oscResampling, 4});
        imAdjRGB = imresize(imAdjRGB, finalSize, {@oscResampling, 4});
        
        try
            imwrite(finalbinaryMask, fullfile(mySettings.directories.segm_saveFMT_foregroundMask,strcat(activeFilename,'scale_1.0_', '_ForegroundSegmented',mySettings.savePrefs.seg_versionID ,mask_FMT)), extractAfter(mask_FMT, '.'),...
                'Compression','none');
            imwrite(imAdjRGB, fullfile(mySettings.directories.segm_saveFMT_adjImage, strcat(activeFilename,'scale_1.0_', '_adjustedRGBImage', mySettings.savePrefs.seg_versionID ,RGB_FMT)), extractAfter(RGB_FMT, '.'), ...
                'Compression','none');
        catch
            imwrite(imresize(finalbinaryMask,0.8, {@oscResampling, 4}) , fullfile(mySettings.directories.segm_saveFMT_foregroundMask,strcat(activeFilename,'scale_0.8_', '_ForegroundSegmented',mySettings.savePrefs.seg_versionID , mask_FMT)), extractAfter(mask_FMT, '.'),...
                'Compression','none');
            imwrite(imresize(imAdjRGB, 0.8, {@oscResampling, 4}), fullfile(mySettings.directories.segm_saveFMT_adjImage, strcat(activeFilename,'scale_0.8_', '_adjustedRGBImage', mySettings.savePrefs.seg_versionID, RGB_FMT)), extractAfter(RGB_FMT, '.'), ...
                'Compression','none');
        end
        
    else
        imwrite(finalbinaryMask, fullfile(mySettings.directories.segm_saveFMT_foregroundMask,strcat( activeFilename,'scale_', sprintf('%.4g', USETHIS_scaleFactor), '_ForegroundSegmented',mySettings.savePrefs.seg_versionID,mask_FMT)), extractAfter(mask_FMT, '.'),...
            'Compression','none');
        
        imwrite(imAdjRGB, fullfile(mySettings.directories.segm_saveFMT_adjImage, strcat( activeFilename,'scale_', sprintf('%.4g', USETHIS_scaleFactor), '_adjustedRGBImage',mySettings.savePrefs.seg_versionID, RGB_FMT)), extractAfter(RGB_FMT, '.'), ...
            'Compression','none');
    end
    
    %/^*^\<--%--->\v.v/<--%->/^*^\<--%--->\v.v/<--%->/^*^\<--%--->\v.v/<--%->/^*^\<--%
    %--%--\v.v/<--%->/^*^\<--%--->\v.v/<--%->/^*^\<--%--->\v.v/<--%->/^*^\<--%--->\v.v/
    
    %% 5. (optional) move file into recycling bin
    recycle on;
    
    if mySettings.seg.seg_deleteYES
        delete(fullfile(mySettings.directories.rawData, activeFilename));
    end
    
    %% 6. Update the counter!
    counter = counter+1;
    
    %% DONE! move on to the next image
end

end






function finalMask = segmentationWrapper(imAdjRGB, varargin)
%% segmentation of the tissue piece from the background.
%
% Inputs    : 1. pre-processed, high resolution whole slide image
%             2. (optional) an already-made segmentation mask delineating foreground/background
%-------------
% Processes : 1. the formation of the initial tissue mask.
%             2. a la carte menu of methods to remake mask or refine one
%             3. saving the mask and the imAdjRGB locally for downstream
%-------------
% Outputs   : 1. segmented binary image (white=foreground)

% Highlights:
% - a few  of the segmentation techniques are (as far as I can tell)
% entirely novel methodologies.
% - The semi-automated approach is very powerful here, as one is forced to
% become very well acquainted with both their data and their code, and
% yet, if done well, minimal biases are introduced.
%  - Some of these segmentation methods are not my own - I credit each
%  as applicable, although I've modified them all to some extent

% CAVEAT, for downstream applications involving high precision
% quantification its inappropriate to pick and choose segmentation methods
% and refinements. Find what works best for your images and stick to that!

% Michael Glendinning, 2022

%% in case there is already a draft mask...
if numel(varargin) > 0 && ismatrix(varargin{1})
    fin_binaryMask = varargin{1};
    
else
    % ... otherwise segment the image initially using morphology
    imAdjRGB_small = imresize(imAdjRGB, 0.9, {@oscResampling, 4});
    binaryMask_small = textureFilterGUI(imAdjRGB_small);
    fin_binaryMask =  imresize(binaryMask_small, size(imAdjRGB, 1:2), {@oscResampling, 4});
end

%% Mask-Refining GUI
finalMask = finalizeMASK(fin_binaryMask,imAdjRGB);

end