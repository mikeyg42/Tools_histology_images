function GA


[filename,pathname]=uigetfile({'*.jpg;*.tif;*.png;*.gif','Choose an image file'});
originpic=imread(fullfile(pathname,filename)); %Raw data; RGB colors of polygons

popusize=input('Input the number of individuals in the population (i.e., population size, e.g., 1000): ');
mostfittedind=input('Input the number of the most fitted individuals that need not to make mutation operations (e.g., 10): ');
accuracy=input('Input the target accuracy (e.g., 0.95): ');
generationmax=input('Input the permitted number of maximum generations (e.g., 10000): ');
probcross=input('Input the probability for crossover (e.g., 0.7): ');
locnumcross=input('Input the number of locations for crossover (e.g., 0.3): ');
probmuta=input('Input the probability for mutation (e.g., 0.001): ');
polygonnum=input('Input the number of polygons (e.g., 100): ');
polygonvert=input('Input the number of vertices of the polygon (e.g., 3): ');
polygontransp=input('Input the transparency of of polygons (e.g., 0.2): ');

close all 
figure;
imshow(originpic);

%Run genetic algorithm
%Pre-operation to calculate image size
[w,l,unuse]=size(originpic);
%Maximal fitness
maxdiff=255^3*3;

%Present numerical expression of original image
picresize=double(imresize(originpic,[256,256]));
totalamount=popusize+mostfittedind;

%% Create initialized population
%Population is represented by a binary matrix of 8*(2*polygonvert+3)*polygonnum a totalamount, where 8 bits of binary value 
% represent a value of 0-255, and each polygon has polygonvert vertices (x,y) and a RGB color

%In ASCII table, 48 and 49 correspond to 0 and 1 respectivelty. For the genes (polygonnum of polygons) of each individual, the
%locations and colors of polygonnum of polygons (genes) are stochastic
si=8*(2*polygonvert+3)*polygonnum;
population=char(randi([48,49],si,totalamount));

%Initial optimal fitness is 0
optimalfitness=0;

%Initial optimal individual genes are empty
optimalgene=char(zeros(si,1));

%The matrix for fitness of every individual
fitnessarray=zeros(1,totalamount);

%%Gentic algorithm
figure('Name','Optimal Gene');
for generationcounter=1:generationmax %Run the bank of individuals
    
    %Calculate fitness
    for i=1:totalamount
        gene=population(:,i);
        fitnessarray(i)=calFitness(picresize,gene,maxdiff,polygonnum,polygonvert,polygontransp);
        if fitnessarray(i)>optimalfitness %Find the optimal solution in population
            optimalfitness=fitnessarray(i);
            optimalgene=gene;
        end
    end
    
    if optimalfitness>=accuracy 
        break;
        %Find the expected solution and calculation ends
    end
    
    %(1) Choose several optimal offspring individuals to the next generation. Sort them from low to high
    
    [unuse,mostfittedindex]=sort(fitnessarray);
    %Choose the most fitted ones
    mostfittedindex=mostfittedindex(end-mostfittedind+1:end);
    %Find them with their indexes
    mostfitted=population(:,mostfittedindex);
    
    %(2) Randomly select individuals, and their probability being selected proportional to their fitness.
    
    %Calculate the probability being selected and further obtain the cumulative probability, and compare to a random value in [0Â¬1]
    %If the random value <= the cumulative probability of individuals and > 1, select the individual to the next generation
    fitnessarray=1-fitnessarray/maxdiff; %Fitness
    fitnessarray=fitnessarray/sum(fitnessarray(:)); %Normalization
    accumulation=cumsum(fitnessarray); %Cumulative probability
    
    %Obtain the column down to up (row right to left) summation matrix corresponding to every element in input matrix
    roulettenumber=rand(1,popusize);
    surviveindex=discretize(roulettenumber,[0,accumulation]);
    newpopulation=population(:,surviveindex);
    newpopulation=[newpopulation,mostfitted];
    newpopulation=newpopulation(:,randperm(totalamount)); %Random disperse the orders of individuals in the new generation
    
    %(3) Crossover. Part of two parent individuals crossover and generate new individuals
    
    %1-single location crossover: there is one random location for crossover
    %2-mutiple locations crossover: there are mutiple random locations for crossover
    %3-even crossover: randomly generate a shield word to determine how the offspring individuals obtain genes from parent
    %individuals
    %Generate shield model
    crossoverindex=rand(1,totalamount/2)<probcross;
    %Shield word string (0-1 string)
    crossovergeneindex=rand(si/8,totalamount/2)<locnumcross;
    crossovergeneindex=repelem(crossovergeneindex,8,1);
    crossovergeneindex(:,~crossoverindex)=0;
    geneindexdiff=zeros(si,totalamount);
    geneindexdiff(:,1:2:totalamount)=crossovergeneindex;
    geneindexdiff(:,2:2:totalamount)=-crossovergeneindex;
    [X,Y]=meshgrid(1:totalamount,1:si);
    newgeneindex=sub2ind([si,totalamount],Y,X+geneindexdiff);
    newpopulation=newpopulation(newgeneindex);
    newpopulation=[newpopulation(1:si,mostfittedind+1:end),mostfitted];
    
    %(4) Mutation
    
    mutationindex=rand(si,totalamount)<probmuta;
    population=char(uint8(xor(newpopulation>48,mutationindex))+48); %or operation
    population=[population(1:si,mostfittedind+1:end),mostfitted];
    disp(['Generation_',num2str(generationcounter),': ',num2str(optimalfitness)]);
    pic=drawPicture(optimalgene,polygonnum,polygonvert,polygontransp);
    pic=imresize(pic,[w,l]);
    imshow(uint8(pic));
end
pic=drawPicture(optimalgene,polygonnum,polygonvert,polygontransp);
pic=imresize(pic,[W,L]);

figure;
imshow(pic); %Present the final fitted image


function fitness=calFitness(pic,gene,maxdiff,polygonnum,polygonvert,polygontransp)

%For every individual, calculate its fitness
[w,l,unuse]=size(pic);

%Gene expression (transform a series of data to an image)
si=8*(2*polygonvert+3)*polygonnum;
nloc=2*polygonvert*polygonnum*8;
polygonloc=gene(1:nloc);
polygoncolor=gene(nloc+1:si);
polygonloc=reshape(polygonloc,2*polygonvert*polygonnum,8);
polygoncolor=reshape(polygoncolor,3*polygonnum,8);
polygonloc=bin2dec(polygonloc)+1; %binary to decimal
polygoncolor=bin2dec(polygoncolor);
polygonloc=reshape(polygonloc,polygonnum,2*polygonvert); %For polygonnum of polygonangles, the subordinates of all

%vertices of every polygon, (x1,y1),(x2,y2),(x3,y3), ..., (x-polygonnum,y-polygonnum)
polygoncolor=reshape(polygoncolor,polygonnum,3); %For polygonnum of polygons, color (RGB) of every polygon

%Generate image
picgene=insertShape(ones(w,l,3)*255,'Filledpolygon',polygonloc,'Color',polygoncolor,'Opacity',polygontransp);
fitness=abs(picgene);
fitness=1-sum(fitness(:))/maxdiff;



function pic=drawPicture(gene,polygonnum,polygonvert,polygontransp)

si=8*(2*polygonvert+3)*polygonnum;

nloc=2*polygonvert*polygonnum*8;

triloc=gene(1:nloc);
tricolor=gene(nloc+1:si);

triloc=reshape(triloc,2*polygonvert*polygonnum,8);
tricolor=reshape(tricolor,3*polygonnum,8);

triloc=bin2dec(triloc)+1;
tricolor=bin2dec(tricolor);

triloc=reshape(triloc,polygonnum,2*polygonvert);
tricolor=reshape(tricolor,polygonnum,3);

pic=insertShape(ones(256,256,3)*255,'FilledPolygon',polygonloc,'Color',polygoncolor,'Opacity',polygontransp);
pic=uint8(pic);



